 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Micro-Voyage VR: The Cellular Network</title>
    <style>
        :root {
            --primary: #ff2a40;
            --secondary: #00e5ff;
            --bg-dark: #070002;
            --text-light: #e0e0e0;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg-dark);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white; user-select: none; -webkit-user-select: none;
        }

        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(30, 5, 10, 0.95) 0%, rgba(0, 0, 0, 1) 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; text-align: center; padding: 2rem; box-sizing: border-box;
            transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(12px);
        }

        .hud-border {
            border: 1px solid rgba(255, 50, 50, 0.3); padding: 40px; border-radius: 20px;
            background: rgba(10, 0, 0, 0.6); box-shadow: 0 0 60px rgba(255, 0, 0, 0.15) inset;
            max-width: 1000px;
        }

        .title-container { margin-bottom: 25px; animation: float 4s ease-in-out infinite; }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-12px); }
            100% { transform: translateY(0px); }
        }

        h1 {
            font-size: 4rem; color: var(--primary); text-transform: uppercase;
            letter-spacing: 6px; margin: 0 0 10px 0;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8), 0 0 10px rgba(255, 100, 100, 0.5);
            animation: pulse-glow 2s infinite alternate;
        }

        @keyframes pulse-glow {
            from { text-shadow: 0 0 20px rgba(255, 0, 0, 0.6); }
            to { text-shadow: 0 0 40px rgba(255, 0, 0, 1), 0 0 20px rgba(255, 100, 100, 0.8); }
        }

        h2 {
            font-size: 1.4rem; color: var(--secondary); letter-spacing: 4px;
            font-weight: 300; margin-top: 0; margin-bottom: 25px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        p.desc {
            font-size: 1.15rem; line-height: 1.8; margin-bottom: 30px;
            color: var(--text-light); text-align: justify;
        }

        .mechanics-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            margin-bottom: 40px; text-align: left;
        }

        .mechanic-card {
            background: rgba(255, 255, 255, 0.05); padding: 18px;
            border-left: 4px solid var(--primary); border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .mechanic-card h3 { margin: 0 0 8px 0; color: #fff; font-size: 1.1rem; text-transform: uppercase;}
        .mechanic-card p { margin: 0; font-size: 0.95rem; color: #bbb; line-height: 1.5; }
        
        .card-lungs { border-color: var(--secondary); }
        .card-kidneys { border-color: #ffd700; }
        .card-brain { border-color: #aa00ff; }
        .card-muscles { border-color: #ff5555; }

        button#start-btn {
            background: linear-gradient(45deg, #990000, #ff1111); color: white;
            border: 2px solid #ff5555; padding: 20px 60px; font-size: 1.5rem;
            font-weight: 800; border-radius: 50px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.4); text-transform: uppercase;
            letter-spacing: 3px;
        }

        button#start-btn:hover {
            transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
            border-color: #ffffff;
        }

        .controls-hint { margin-top: 25px; font-size: 0.9rem; color: #888; line-height: 1.6; }

        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; color: white; font-size: 1.5rem; transition: opacity 1s; letter-spacing: 2px;
        }

        .spinner {
            border: 6px solid #222; border-top: 6px solid var(--primary); border-radius: 50%;
            width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #gaze-reticle {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            margin-top: -10px; margin-left: -10px; border: 3px solid rgba(255,255,255,0.6);
            border-radius: 50%; pointer-events: none; z-index: 500; display: none;
            transition: all 0.2s ease-out; box-shadow: 0 0 15px rgba(0,0,0,0.5);
            box-sizing: border-box; background: rgba(255,255,255,0.1);
        }
        
        #gaze-reticle.active {
            border-color: var(--secondary); background: rgba(0, 229, 255, 0.3);
            box-shadow: 0 0 25px var(--secondary); transform: scale(2.0);
        }

        #desktop-hud {
            position: absolute; bottom: 20px; left: 20px; background: rgba(10, 15, 20, 0.85);
            border: 1px solid rgba(0, 229, 255, 0.4); border-radius: 12px; padding: 20px;
            width: 320px; display: none; pointer-events: none; z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px);
        }

        .hud-row { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.95rem; }
        .hud-label { color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .hud-value { color: #fff; font-weight: bold; font-family: monospace; font-size: 1.1rem; }
        .hud-value.highlight { color: var(--secondary); }
        .hud-value.danger { color: var(--primary); }

        .bar-bg { width: 100%; height: 8px; background: #222; border-radius: 4px; margin-top: 5px; overflow: hidden; }
        .bar-fill-o2 { height: 100%; background: #00e5ff; width: 100%; transition: width 0.3s; }
        .bar-fill-waste { height: 100%; background: #ffd700; width: 0%; transition: width 0.3s; }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.4) 100%);
            opacity: 0; pointer-events: none; z-index: 50; transition: opacity 0.3s ease;
        }

        #branch-alert {
            position: absolute; top: 40px; width: 100%; text-align: center;
            font-size: 1.8rem; color: #ffff00; font-weight: bold; text-shadow: 0 0 20px #ff0000;
            display: none; pointer-events: none; z-index: 500; letter-spacing: 3px;
            animation: flashText 1s infinite alternate;
        }
        @keyframes flashText { from { opacity: 0.6; transform: scale(0.98); } to { opacity: 1; transform: scale(1.02); } }
        
        #VRButton { z-index: 9999 !important; border: 1px solid var(--secondary) !important; background: rgba(0, 50, 60, 0.8) !important; }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="loading-screen">
        <div class="spinner"></div>
        <div>SYNTHESIZING BIOLOGICAL TISSUES...</div>
    </div>

    <div id="ui-overlay" style="display: none;">
        <div class="hud-border">
            <div class="title-container">
                <h1>Micro-Voyage VR</h1>
                <h2>THE CELLULAR NETWORK</h2>
            </div>
            
            <p class="desc">
                Shrink down to a microscopic scale and pilot an automated nanite through a living human circulatory system. 
                You are no longer a passive observer‚Äîyou must actively navigate the biological network to manage your physiological parameters.
            </p>
            
            <div class="mechanics-grid">
                <div class="mechanic-card card-lungs">
                    <h3>ü´Å The Lungs</h3>
                    <p>Travel to the pulmonary circuit to <strong style="color:var(--secondary)">replenish Oxygen</strong>. Watch depleted cells turn bright crimson.</p>
                </div>
                <div class="mechanic-card card-muscles">
                    <h3>üí™ Skeletal Muscle</h3>
                    <p>High energy demand. Supplying muscles <strong style="color:var(--primary)">depletes Oxygen</strong> rapidly and generates metabolic waste.</p>
                </div>
                <div class="mechanic-card card-kidneys">
                    <h3>üî¨ Kidneys / Nephrons</h3>
                    <p>The body's filtration system. Travel here to <strong style="color:#ffd700">filter out Toxic Waste</strong> from the plasma.</p>
                </div>
                <div class="mechanic-card card-brain">
                    <h3>üß† Cerebral Cortex</h3>
                    <p>Requires constant energy. Watch electrical neurons fire across synapses as you deliver vital nutrients.</p>
                </div>
            </div>
            
            <button id="start-btn">INITIATE SEQUENCE</button>
            
            <p class="controls-hint">
                <strong>DESKTOP:</strong> Click & Drag to look around. Look directly at Holographic Portals to steer. Hold Click to boost speed.<br>
                <strong>VR HEADSET:</strong> Look freely. Gaze at Portals to select your path. Squeeze Trigger to boost speed.
            </p>
        </div>
    </div>

    <div id="gaze-reticle"></div>
    <div id="branch-alert">‚ö†Ô∏è AORTIC BIFURCATION AHEAD: GAZE TO CHOOSE PATH ‚ö†Ô∏è</div>
    
    <div id="desktop-hud">
        <div class="hud-row">
            <span class="hud-label">Region</span>
            <span class="hud-value highlight" id="ui-region">Heart</span>
        </div>
        <div class="hud-row">
            <span class="hud-label">Heart Rate</span>
            <span class="hud-value danger" id="ui-bpm">65 BPM</span>
        </div>
        <div class="hud-row" style="margin-bottom: 2px;">
            <span class="hud-label">Oxygen Saturation</span>
            <span class="hud-value" id="ui-o2-text">100%</span>
        </div>
        <div class="bar-bg"><div class="bar-fill-o2" id="ui-o2-bar"></div></div>
        
        <div class="hud-row" style="margin-top: 15px; margin-bottom: 2px;">
            <span class="hud-label">Metabolic Waste</span>
            <span class="hud-value" id="ui-waste-text" style="color:#ffd700;">0%</span>
        </div>
        <div class="bar-bg"><div class="bar-fill-waste" id="ui-waste-bar"></div></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        const BiologyState = {
            oxygen: 1.0,
            waste: 0.0,
            heartRate: 65,
            speedBase: 50.0,
            speedMult: 1.0,
            isBoosting: false,
            timeElapsed: 0
        };

        const BiomeType = {
            HEART: 0, LUNGS: 1, MUSCLES: 2, KIDNEYS: 3, BRAIN: 4, VEIN: 5
        };

        let scene, camera, renderer, clock;
        let playerRig, dolly;
        
        let currentTrackId = 'track_heart';
        let splineT = 0.02;
        
        let raycaster = new THREE.Raycaster();
        let centerScreen = new THREE.Vector2(0,0);
        let activeGazeTargets = [];
        let selectedBranchId = null;
        let gazeTimer = 0;
        const GAZE_REQUIRED = 1.2;
        
        let isDragging = false;
        let targetRotX = 0, targetRotY = 0;
        let prevMouse = { x: 0, y: 0 };

        const CONFIG = {
            segments: 300,
            radius: 20,
            junctionDistance: 0.82
        };

        const GraphData = {};
        let AudioSys, EnvironmentSys, CellSys, UISys;

        const math_pos = new THREE.Vector3();
        const math_quat = new THREE.Quaternion();
        const math_mat = new THREE.Matrix4();

        class BiologicalGraphEdge {
            constructor(id, controlPoints, type, nextIds, title, description) {
                this.id = id;
                this.type = type; 
                this.nextIds = nextIds; 
                this.title = title;
                this.description = description;

                this.curve = new THREE.CatmullRomCurve3(controlPoints, false, 'centripetal', 0.5);
                this.length = this.curve.getLength();
                
                this.points = this.curve.getSpacedPoints(CONFIG.segments);
                this.frames = this.curve.computeFrenetFrames(CONFIG.segments, false);
                
                this.geometry = new THREE.TubeGeometry(this.curve, CONFIG.segments, CONFIG.radius, 20, false);
                this.deformGeometry(this.geometry, type);
                
                this.material = this.createBiologicalMaterial(type);
                this.mesh = new THREE.Mesh(this.geometry, this.material);
            }

            deformGeometry(geometry, type) {
                const pos = geometry.attributes.position;
                const norm = geometry.attributes.normal;
                const uv = geometry.attributes.uv;
                const v = new THREE.Vector3();

                for (let i = 0; i < pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const n = new THREE.Vector3().fromBufferAttribute(norm, i);
                    const t = uv.getX(i);

                    const noise = Math.sin(v.x * 0.2) * Math.cos(v.y * 0.2) * Math.sin(v.z * 0.2);
                    v.addScaledVector(n, noise * 2.0);

                    if (type === BiomeType.LUNGS) {
                        let peak = Math.sin(t * Math.PI); 
                        if (t > 0.15 && t < 0.85) peak = 1.0; else peak = Math.sin((t < 0.15 ? t/0.15 : (1-t)/0.15) * Math.PI/2);
                        v.y -= (v.y - this.curve.getPointAt(t).y) * peak * 0.8;
                        v.x += n.x * peak * 35;
                        v.z += n.z * peak * 35;
                    } else if (type === BiomeType.HEART) {
                        const hDiff = Math.abs(t - 0.45);
                        if (hDiff < 0.25) {
                            const bulge = Math.pow(Math.cos((hDiff / 0.25) * (Math.PI / 2)), 2) * 70;
                            v.addScaledVector(n, bulge);
                        }
                    } else if (type === BiomeType.MUSCLES) {
                        v.addScaledVector(n, -Math.sin(t * Math.PI) * 7);
                    }

                    pos.setXYZ(i, v.x, v.y, v.z);
                }
                geometry.computeVertexNormals();
            }

            createBiologicalMaterial(type) {
                let col = 0x880000, em = 0x220000;
                if (type === BiomeType.LUNGS) { col = 0x004455; em = 0x001122; }
                if (type === BiomeType.KIDNEYS) { col = 0x554400; em = 0x221100; }
                if (type === BiomeType.BRAIN) { col = 0x220044; em = 0x110022; }
                if (type === BiomeType.VEIN) { col = 0x330022; em = 0x110011; }

                const mat = new THREE.MeshStandardMaterial({
                    color: col, emissive: em, roughness: 0.5, metalness: 0.1, side: THREE.BackSide
                });

                mat.onBeforeCompile = (shader) => {
                    shader.uniforms.uTime = { value: 0 };
                    shader.uniforms.uPulse = { value: 0 };
                    shader.uniforms.uType = { value: type };

                    shader.vertexShader = `
                        uniform float uTime; uniform float uPulse; uniform float uType;
                        varying vec2 vUvFlow;
                        ${shader.vertexShader}
                    `;
                    shader.vertexShader = shader.vertexShader.replace(
                        '#include <begin_vertex>',
                        `
                        #include <begin_vertex>
                        vUvFlow = uv;
                        float wave = sin(uv.x * 60.0 - uTime * 4.0) * cos(uv.y * 20.0) * 1.5;
                        float pAmp = (uType == 0.0) ? 8.0 : 1.5;
                        transformed += normal * (wave + (uPulse * pAmp));
                        `
                    );

                    shader.fragmentShader = `
                        uniform float uTime; uniform float uType;
                        varying vec2 vUvFlow;
                        ${shader.fragmentShader}
                    `;
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <map_fragment>',
                        `
                        #include <map_fragment>
                        float line = abs(sin(vUvFlow.x * 200.0 + uTime) * cos(vUvFlow.y * 40.0));
                        diffuseColor.rgb += vec3(line * 0.12);
                        
                        if (uType == 1.0) {
                            diffuseColor.rgb = mix(diffuseColor.rgb, vec3(0.0, 0.8, 1.0), line * 0.25);
                        } else if (uType == 3.0) {
                            diffuseColor.rgb = mix(diffuseColor.rgb, vec3(0.8, 0.9, 0.0), line * 0.25);
                        } else if (uType == 4.0) {
                            float spark = pow(abs(sin(vUvFlow.x * 100.0 - uTime * 8.0) * cos(vUvFlow.y * 100.0)), 15.0);
                            diffuseColor.rgb += vec3(0.5, 0.5, 1.0) * spark * 4.0;
                        }
                        `
                    );
                    mat.userData.shader = shader;
                };
                return mat;
            }

            updateUniforms(time, pulse) {
                if (this.mesh.material.userData.shader) {
                    this.mesh.material.userData.shader.uniforms.uTime.value = time;
                    this.mesh.material.userData.shader.uniforms.uPulse.value = pulse;
                }
            }

            getInterpolatedTransform(t) {
                const floatIdx = t * (CONFIG.segments - 1);
                const idx = Math.floor(floatIdx);
                const frac = floatIdx - idx;
                
                const p0 = this.points[idx];
                const p1 = this.points[Math.min(idx + 1, CONFIG.segments - 1)];
                const pos = new THREE.Vector3().lerpVectors(p0, p1, frac);
                
                const n0 = this.frames.normals[idx];
                const n1 = this.frames.normals[Math.min(idx + 1, CONFIG.segments - 1)];
                const norm = new THREE.Vector3().lerpVectors(n0, n1, frac).normalize();
                
                const b0 = this.frames.binormals[idx];
                const b1 = this.frames.binormals[Math.min(idx + 1, CONFIG.segments - 1)];
                const binorm = new THREE.Vector3().lerpVectors(b0, b1, frac).normalize();
                
                const t0 = this.frames.tangents[idx];
                const t1 = this.frames.tangents[Math.min(idx + 1, CONFIG.segments - 1)];
                const tang = new THREE.Vector3().lerpVectors(t0, t1, frac).normalize();
                
                return { pos, norm, binorm, tang };
            }
        }

        function generateNetworkGraph() {
            const v = (x,y,z) => new THREE.Vector3(x,y,z);

            const pHeart = [
                v(0,0,0), v(0,-30,-50), v(0,-50,-150), v(0,-20,-250)
            ];
            GraphData['track_heart'] = new BiologicalGraphEdge('track_heart', pHeart, BiomeType.HEART, ['track_aorta'], 
                "Left Ventricle", "The heart's main pumping chamber. Get ready for launch into the Aorta.");

            const pAorta = [
                v(0,-20,-250), v(50, 20, -300), v(150, 50, -350), v(250, 0, -400)
            ];
            GraphData['track_aorta'] = new BiologicalGraphEdge('track_aorta', pAorta, BiomeType.HEART, ['track_brain', 'track_muscles', 'track_kidneys', 'track_lungs'], 
                "The Aortic Arch", "The massive central highway of the body. You are approaching a bifurcation.");

            const pBrain = [
                v(250, 0, -400), v(300, 200, -450), v(350, 400, -500), v(200, 500, -550),
                v(50, 400, -500), v(-50, 200, -400), v(-100, 50, -200), v(0,0,0)
            ];
            GraphData['track_brain'] = new BiologicalGraphEdge('track_brain', pBrain, BiomeType.BRAIN, ['track_heart'], 
                "Cerebral Cortex", "Watch the glowing neurons fire. The brain rapidly depletes oxygen.");

            const pMuscle = [
                v(250, 0, -400), v(350, -100, -500), v(400, -300, -600), v(300, -400, -500),
                v(150, -300, -400), v(50, -150, -200), v(0,0,0)
            ];
            GraphData['track_muscles'] = new BiologicalGraphEdge('track_muscles', pMuscle, BiomeType.MUSCLES, ['track_heart'], 
                "Skeletal Muscle", "Muscles burn massive amounts of O2 and dump Lactic Acid (Waste) into the plasma.");

            const pKidney = [
                v(250, 0, -400), v(200, -200, -350), v(150, -400, -300), v(0, -500, -200),
                v(-100, -350, -100), v(-50, -150, -50), v(0,0,0)
            ];
            GraphData['track_kidneys'] = new BiologicalGraphEdge('track_kidneys', pKidney, BiomeType.KIDNEYS, ['track_heart'], 
                "Renal Nephrons", "The filtration plant. Notice the glowing yellow toxic waste being scrubbed out.");

            const pLungs = [
                v(250, 0, -400), v(100, 50, -500), v(-100, 80, -600), v(-300, 50, -500),
                v(-250, 0, -300), v(-100, -20, -150), v(0,0,0)
            ];
            GraphData['track_lungs'] = new BiologicalGraphEdge('track_lungs', pLungs, BiomeType.LUNGS, ['track_heart'], 
                "Alveolar Capillaries", "Vessels narrow drastically here. Carbon Dioxide is expelled and fresh Oxygen binds to cells.");

            for(let key in GraphData) scene.add(GraphData[key].mesh);
        }

        class EnvironmentManager {
            constructor() {
                this.signs = [];
                this.portals = [];
                this.setupLighting();
                this.placeSignage();
            }

            setupLighting() {
                scene.add(new THREE.AmbientLight(0xffaaaa, 0.4));
                const cLight = new THREE.PointLight(0xff0000, 0, 800);
                scene.add(cLight);
                this.centerLight = cLight;
            }

            createGlassPanel(title, text, colorHex, isPortal = false) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = isPortal ? 'rgba(0, 20, 10, 0.8)' : 'rgba(5, 10, 20, 0.85)';
                ctx.beginPath(); ctx.roundRect(0, 0, 1024, 512, 40); ctx.fill();
                ctx.lineWidth = 10; ctx.strokeStyle = colorHex; ctx.stroke();
                
                ctx.fillStyle = colorHex;
                
                if (isPortal) {
                    ctx.font = 'bold 75px sans-serif'; ctx.textAlign = 'center';
                    ctx.fillText("GAZE TO SELECT", 512, 180);
                    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 100px sans-serif';
                    ctx.fillText(title, 512, 350);
                } else {
                    ctx.font = 'bold 60px sans-serif'; ctx.textAlign = 'left';
                    ctx.fillText(title, 60, 100);
                    ctx.beginPath(); ctx.moveTo(60, 130); ctx.lineTo(964, 130); ctx.stroke();

                    ctx.fillStyle = '#e0e0e0'; ctx.font = '45px sans-serif';
                    const words = text.split(' ');
                    let line = '', y = 210;
                    for(let n = 0; n < words.length; n++) {
                        const testLine = line + words[n] + ' ';
                        if (ctx.measureText(testLine).width > 900 && n > 0) {
                            ctx.fillText(line, 60, y); line = words[n] + ' '; y += 60;
                        } else line = testLine;
                    }
                    ctx.fillText(line, 60, y);
                }

                const mat = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, side: THREE.DoubleSide, depthTest: !isPortal });
                return new THREE.Mesh(new THREE.PlaneGeometry(16, 8), mat);
            }

            placeSignage() {
                const addInfo = (trackId, tPos, title, text) => {
                    const trk = GraphData[trackId];
                    const frame = trk.getInterpolatedTransform(tPos);
                    const mesh = this.createGlassPanel(title, text, '#00e5ff');
                    
                    mesh.position.copy(frame.pos).addScaledVector(frame.binorm, 12).addScaledVector(frame.norm, -5);
                    mesh.lookAt(frame.pos.clone().addScaledVector(frame.tang, -10));
                    scene.add(mesh);
                };

                addInfo('track_heart', 0.2, "Ventricular Contraction", "The immense pressure here pushes blood throughout the entire body.");
                addInfo('track_aorta', 0.2, "Aortic Arch", "Blood is fully oxygenated. Prepare for the bifurcation ahead.");
                addInfo('track_lungs', 0.5, "Gas Exchange", "Notice how the Red Blood Cells shift from dark purple to bright red as they absorb O2.");
                addInfo('track_kidneys', 0.4, "Renal Filtration", "Millions of nephrons are scrubbing metabolic waste (yellow particles) from the plasma.");
                addInfo('track_brain', 0.3, "High Consumption", "Neurons demand massive energy. Oxygen levels will deplete rapidly here.");
            }

            spawnJunctionPortals(track) {
                if(this.portals.length > 0) return;
                
                track.nextIds.forEach((nextId, idx) => {
                    const nTrk = GraphData[nextId];
                    let title = "UNKNOWN", col = "#ffffff";
                    if (nTrk.type === BiomeType.LUNGS) { title = "LUNGS"; col = "#00e5ff"; }
                    else if (nTrk.type === BiomeType.MUSCLES) { title = "MUSCLES"; col = "#ff3344"; }
                    else if (nTrk.type === BiomeType.KIDNEYS) { title = "KIDNEYS"; col = "#ffd700"; }
                    else if (nTrk.type === BiomeType.BRAIN) { title = "BRAIN"; col = "#aa00ff"; }

                    const mesh = this.createGlassPanel(title, "", col, true);
                    
                    const pIdx = Math.floor(0.95 * CONFIG.segments);
                    const pos = track.points[pIdx].clone();
                    
                    const angle = (idx / track.nextIds.length) * Math.PI * 2 + (Math.PI/4);
                    pos.addScaledVector(track.frames.binormals[pIdx], Math.cos(angle) * 14);
                    pos.addScaledVector(track.frames.normals[pIdx], Math.sin(angle) * 14);
                    
                    mesh.position.copy(pos);
                    mesh.lookAt(track.points[pIdx - 10]);
                    mesh.userData = { id: nextId, color: col };
                    
                    scene.add(mesh);
                    this.portals.push(mesh);
                });
            }

            clearPortals() {
                this.portals.forEach(p => scene.remove(p));
                this.portals = [];
            }
        }

        class CellularSimulation {
            constructor() {
                this.rbcCount = 6000;
                this.wbcCount = 150;
                this.wasteCount = 1500;
                this.dummy = new THREE.Object3D();
                this.colDummy = new THREE.Color();
                
                this.initMeshes();
            }

            createData(count, radSpread, speedVar) {
                const arr = [];
                const keys = Object.keys(GraphData);
                for(let i=0; i<count; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * radSpread;
                    arr.push({
                        trackId: keys[Math.floor(Math.random() * keys.length)],
                        t: Math.random(),
                        speedMod: 1.0 + (Math.random() - 0.5) * speedVar,
                        offR: Math.cos(ang) * r,
                        offU: Math.sin(ang) * r,
                        rot: new THREE.Vector3(Math.random()*3, Math.random()*3, Math.random()*3),
                        rotSpd: new THREE.Vector3((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1),
                        hidden: false
                    });
                }
                return arr;
            }

            initMeshes() {
                const rGeo = new THREE.CylinderGeometry(1.3, 1.3, 0.5, 16, 1);
                const rPos = rGeo.attributes.position;
                for(let i=0; i<rPos.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(rPos, i);
                    const d = Math.sqrt(v.x*v.x + v.z*v.z);
                    if (d < 0.9 && Math.abs(v.y) > 0.1) v.y *= (1.0 - Math.cos((d/0.9)*Math.PI/2) * 0.7);
                    rPos.setXYZ(i, v.x, v.y, v.z);
                }
                rGeo.computeVertexNormals();
                this.rbcMesh = new THREE.InstancedMesh(rGeo, new THREE.MeshStandardMaterial({roughness:0.3, color:0xffffff}), this.rbcCount);
                this.rbcMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(this.rbcCount * 3), 3);
                this.rbcData = this.createData(this.rbcCount, CONFIG.radius - 3, 0.4);
                scene.add(this.rbcMesh);

                const wGeo = new THREE.IcosahedronGeometry(2.0, 3);
                const wPos = wGeo.attributes.position;
                for(let i=0; i<wPos.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(wPos, i);
                    v.addScaledVector(v.clone().normalize(), Math.sin(v.x*8)*Math.cos(v.y*8)*0.3);
                    wPos.setXYZ(i, v.x, v.y, v.z);
                }
                wGeo.computeVertexNormals();
                this.wbcMesh = new THREE.InstancedMesh(wGeo, new THREE.MeshStandardMaterial({color:0xddeeff, roughness:0.9}), this.wbcCount);
                this.wbcData = this.createData(this.wbcCount, CONFIG.radius - 5, 0.2);
                scene.add(this.wbcMesh);

                const wasteGeo = new THREE.TetrahedronGeometry(0.6, 1);
                this.wasteMesh = new THREE.InstancedMesh(wasteGeo, new THREE.MeshStandardMaterial({color:0xffff00, roughness:0.6}), this.wasteCount);
                this.wasteData = this.createData(this.wasteCount, CONFIG.radius - 2, 0.6);
                scene.add(this.wasteMesh);
            }

            update(delta, playerSpeed, time) {
                this.updateGroup(this.rbcMesh, this.rbcData, delta, playerSpeed, time, true, false);
                this.updateGroup(this.wbcMesh, this.wbcData, delta, playerSpeed, time, false, false);
                this.updateGroup(this.wasteMesh, this.wasteData, delta, playerSpeed, time, false, true);
            }

            updateGroup(mesh, dataArr, delta, playerSpeed, time, isRBC, isWaste) {
                for(let i=0; i<dataArr.length; i++) {
                    const d = dataArr[i];
                    let trk = GraphData[d.trackId];
                    
                    d.t += (playerSpeed * d.speedMod * delta) / trk.length;
                    
                    if (d.t >= 1.0) {
                        d.t -= 1.0;
                        if (trk.nextIds.length > 0) d.trackId = trk.nextIds[Math.floor(Math.random() * trk.nextIds.length)];
                        else d.trackId = 'track_heart';
                        trk = GraphData[d.trackId];
                        d.hidden = false;
                    }

                    if (isWaste && trk.type === BiomeType.KIDNEYS && d.t > 0.3) {
                        if (Math.random() < 0.05) d.hidden = true;
                    }
                    if (d.hidden) {
                        this.dummy.scale.setScalar(0);
                    } else {
                        this.dummy.scale.setScalar(1);
                        
                        const frame = trk.getInterpolatedTransform(d.t);
                        let finalR = d.offR; let finalU = d.offU;

                        if (trk.type === BiomeType.LUNGS) {
                            let peak = Math.sin(d.t * Math.PI); 
                            if(d.t>0.15 && d.t<0.85) peak=1.0; else peak = Math.sin((d.t<0.15 ? d.t/0.15 : (1-d.t)/0.15) * Math.PI/2);
                            frame.pos.y -= (frame.pos.y - trk.curve.getPointAt(d.t).y) * peak * 0.8;
                            finalU *= (1.0 - peak * 0.8);
                            finalR *= (1.0 + peak * 1.5);
                        } else if (trk.type === BiomeType.HEART) {
                            const hDiff = Math.abs(d.t - 0.45);
                            if (hDiff < 0.25) {
                                const bulge = Math.pow(Math.cos((hDiff / 0.25) * (Math.PI / 2)), 2) * 3.0;
                                finalR *= (1.0 + bulge); finalU *= (1.0 + bulge);
                            }
                        }

                        frame.pos.addScaledVector(frame.norm, finalR).addScaledVector(frame.binorm, finalU);
                        frame.pos.x += Math.sin(time*2 + i)*0.5;

                        this.dummy.position.copy(frame.pos);
                        d.rot.add(d.rotSpd);
                        this.dummy.rotation.setFromVector3(d.rot);
                    }
                    
                    this.dummy.updateMatrix();
                    mesh.setMatrixAt(i, this.dummy.matrix);

                    if (isRBC) {
                        let c = this.colDummy;
                        if (trk.type === BiomeType.LUNGS) {
                            const f = Math.min(1.0, d.t * 2);
                            c.setRGB(0.3 + f*0.7, 0.0, 0.2 - f*0.1);
                        } else if (trk.type === BiomeType.MUSCLES || trk.type === BiomeType.BRAIN) {
                            const f = Math.min(1.0, d.t * 1.5);
                            c.setRGB(1.0 - f*0.7, 0.0, 0.1 + f*0.1);
                        } else if (trk.type === BiomeType.HEART) {
                            c.setRGB(0.5, 0.0, 0.15);
                        } else {
                            c.setRGB(1.0, 0.05, 0.05);
                        }
                        mesh.setColorAt(i, c);
                    }
                }
                mesh.instanceMatrix.needsUpdate = true;
                if(isRBC) mesh.instanceColor.needsUpdate = true;
            }
        }

        class AudioEngine {
            constructor() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.6;
                this.master.connect(this.ctx.destination);
                
                this.lastBeat = 0;
                this.setupFluidHum();
            }

            init() { if (this.ctx.state === 'suspended') this.ctx.resume(); }

            setupFluidHum() {
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;

                this.noiseSrc = this.ctx.createBufferSource();
                this.noiseSrc.buffer = buffer;
                this.noiseSrc.loop = true;

                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                
                this.flowGain = this.ctx.createGain();
                this.flowGain.gain.value = 0.05;

                this.noiseSrc.connect(this.filter);
                this.filter.connect(this.flowGain);
                this.flowGain.connect(this.master);
                this.noiseSrc.start();
            }

            playHeartbeat(offset, isHeavy) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.master);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(isHeavy ? 55 : 35, this.ctx.currentTime + offset);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + offset + 0.15);
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime + offset);
                gain.gain.linearRampToValueAtTime(isHeavy ? 1.0 : 0.6, this.ctx.currentTime + offset + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + offset + 0.25);
                
                osc.start(this.ctx.currentTime + offset);
                osc.stop(this.ctx.currentTime + offset + 0.3);
            }

            playUIChime() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.master);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.start(); osc.stop(this.ctx.currentTime + 0.4);
            }

            update(speedMult, time) {
                this.filter.frequency.setTargetAtTime(250 + (speedMult * 400), this.ctx.currentTime, 0.1);
                this.flowGain.gain.setTargetAtTime(0.03 + (speedMult * 0.08), this.ctx.currentTime, 0.1);

                const interval = 60 / BiologyState.heartRate;
                if (time - this.lastBeat > interval) {
                    this.playHeartbeat(0, true);
                    this.playHeartbeat(0.25, false);
                    this.lastBeat = time;
                }
            }
        }

        class UIManager {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.canvas.width = 1024; this.canvas.height = 256;
                this.ctx = this.canvas.getContext('2d');
                this.texture = new THREE.CanvasTexture(this.canvas);
                
                const mat = new THREE.MeshBasicMaterial({ map: this.texture, transparent: true, depthTest: false });
                this.vrMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 0.35), mat);
                this.vrMesh.position.set(0, -0.45, -1.2);
                this.vrMesh.renderOrder = 999;
                
                camera.add(this.vrMesh); // Parent to camera
                // FIX: Do NOT call scene.add(camera) here ‚Äî camera is already in
                // the scene graph via dolly -> playerRig -> camera. Reparenting it
                // to the scene root broke all dolly-based movement.
            }

            update(trackTitle) {
                document.getElementById('ui-region').innerText = trackTitle;
                document.getElementById('ui-bpm').innerText = `${BiologyState.heartRate} BPM`;
                document.getElementById('ui-o2-text').innerText = `${Math.floor(BiologyState.oxygen * 100)}%`;
                document.getElementById('ui-o2-bar').style.width = `${BiologyState.oxygen * 100}%`;
                
                document.getElementById('ui-waste-text').innerText = `${Math.floor(BiologyState.waste * 100)}%`;
                document.getElementById('ui-waste-bar').style.width = `${BiologyState.waste * 100}%`;

                const dmg = document.getElementById('damage-overlay');
                if (BiologyState.oxygen < 0.25 || BiologyState.waste > 0.75) {
                    dmg.style.opacity = Math.sin(BiologyState.timeElapsed * 6) * 0.4 + 0.4;
                } else {
                    dmg.style.opacity = 0;
                }

                const c = this.ctx;
                c.clearRect(0,0,1024,256);
                
                c.fillStyle = 'rgba(5, 10, 20, 0.7)';
                c.beginPath(); c.roundRect(10, 10, 1004, 236, 15); c.fill();
                c.strokeStyle = 'rgba(0, 229, 255, 0.5)'; c.lineWidth = 4; c.stroke();

                c.fillStyle = '#ffffff'; c.font = 'bold 36px monospace'; c.textAlign = 'left';
                c.fillText(`REGION: ${trackTitle.toUpperCase()}`, 30, 60);
                c.fillText(`SPEED : ${(BiologyState.speedMult * 100).toFixed(0)} ¬µm/s`, 30, 130);
                c.fillStyle = '#ff4444'; c.fillText(`BPM   : ${BiologyState.heartRate} ‚ù§Ô∏è`, 30, 200);

                c.textAlign = 'right'; c.fillStyle = '#ffffff';
                c.fillText('O2 SATURATION', 980, 60);
                this.drawBar(c, 980, 80, BiologyState.oxygen, '#00e5ff');
                c.fillStyle = '#ffffff';
                c.fillText('METABOLIC WASTE', 980, 170);
                this.drawBar(c, 980, 190, BiologyState.waste, '#ffd700');

                this.texture.needsUpdate = true;
            }

            drawBar(ctx, xR, y, percent, color) {
                const w = 350; const h = 25;
                ctx.fillStyle = 'rgba(50,50,50,0.8)'; ctx.fillRect(xR - w, y, w, h);
                ctx.fillStyle = color; ctx.fillRect(xR - w, y, w * percent, h);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(xR - w, y, w, h);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050005);
            scene.fog = new THREE.FogExp2(0x050005, 0.012);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            playerRig = new THREE.Group();
            dolly = new THREE.Group();
            playerRig.add(camera);
            dolly.add(playerRig);
            scene.add(dolly);

            const headLamp = new THREE.PointLight(0xffffff, 150, 200);
            camera.add(headLamp);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            clock = new THREE.Clock();

            generateNetworkGraph();
            EnvironmentSys = new EnvironmentManager();
            CellSys = new CellularSimulation();
            UISys = new UIManager();
            AudioSys = new AudioEngine();

            setupControls();

            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('ui-overlay').style.display = 'flex';
            }, 1000);

            document.getElementById('start-btn').addEventListener('click', startGame);
        }

        function startGame() {
            document.getElementById('ui-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('ui-overlay').style.display = 'none';
                if (!renderer.xr.isPresenting) {
                    document.getElementById('desktop-hud').style.display = 'block';
                    document.getElementById('gaze-reticle').style.display = 'block';
                    UISys.vrMesh.visible = false;
                }
            }, 1200);

            AudioSys.init();
            
            const frame = GraphData[currentTrackId].getInterpolatedTransform(splineT);
            dolly.position.copy(frame.pos);

            renderer.setAnimationLoop(animate);
        }

        function setupControls() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            const boost = () => BiologyState.isBoosting = true;
            const ease = () => BiologyState.isBoosting = false;

            window.addEventListener('mousedown', (e) => { if(e.button===0){ boost(); isDragging=true; prevMouse={x:e.clientX, y:e.clientY}; }});
            window.addEventListener('mouseup', () => { ease(); isDragging = false; });
            window.addEventListener('touchstart', (e) => { boost(); isDragging=true; prevMouse={x:e.touches[0].clientX, y:e.touches[0].clientY}; });
            window.addEventListener('touchend', () => { ease(); isDragging = false; });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && !renderer.xr.isPresenting) {
                    targetRotY -= (e.clientX - prevMouse.x) * 0.003;
                    targetRotX -= (e.clientY - prevMouse.y) * 0.003;
                    targetRotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotX));
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
                centerScreen.x = (e.clientX / window.innerWidth) * 2 - 1;
                centerScreen.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            renderer.xr.addEventListener('sessionstart', () => {
                const s = renderer.xr.getSession();
                s.addEventListener('selectstart', boost);
                s.addEventListener('selectend', ease);
                document.getElementById('desktop-hud').style.display = 'none';
                document.getElementById('gaze-reticle').style.display = 'none';
                UISys.vrMesh.visible = true;
            });
        }

        function handleBranchingLogic(trk, delta) {
            const isJunction = (trk.nextIds.length > 1 && splineT > CONFIG.junctionDistance);
            const alertDom = document.getElementById('branch-alert');

            if (isJunction) {
                alertDom.style.display = 'block';
                EnvironmentSys.spawnJunctionPortals(trk);

                if (renderer.xr.isPresenting) raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                else raycaster.setFromCamera(centerScreen, camera);

                const hits = raycaster.intersectObjects(EnvironmentSys.portals, false);
                const reticle = document.getElementById('gaze-reticle');

                if (hits.length > 0) {
                    const hit = hits[0].object;
                    hit.scale.set(1.1, 1.1, 1.1);
                    
                    if (selectedBranchId !== hit.userData.id) {
                        gazeTimer += delta * 2;
                        
                        if (!renderer.xr.isPresenting) {
                            reticle.classList.add('active');
                            reticle.style.borderColor = hit.userData.color;
                        }
                        
                        const prog = gazeTimer / GAZE_REQUIRED;
                        hit.material.color.lerpColors(new THREE.Color(hit.userData.color), new THREE.Color(0x00ff00), prog);

                        if (gazeTimer >= GAZE_REQUIRED) {
                            selectedBranchId = hit.userData.id;
                            AudioSys.playUIChime();
                            scene.background = new THREE.Color(0xffffff);
                            reticle.classList.remove('active');
                            gazeTimer = 0;
                            EnvironmentSys.portals.forEach(p => { if(p!==hit) p.material.opacity = 0.1; });
                        }
                    }
                } else {
                    gazeTimer = 0;
                    if (!renderer.xr.isPresenting) reticle.classList.remove('active');
                    EnvironmentSys.portals.forEach(p => { p.scale.setScalar(1); p.material.color.set(p.userData.color); });
                }
                
                return 0.1;
            } else {
                alertDom.style.display = 'none';
                return 1.0;
            }
        }

        function animate() {
            const delta = Math.min(clock.getDelta(), 0.1); 
            const time = clock.getElapsedTime();
            BiologyState.timeElapsed = time;

            const targetSpeed = BiologyState.isBoosting ? 3.5 : 1.0;
            BiologyState.speedMult += (targetSpeed - BiologyState.speedMult) * 6.0 * delta;

            const trk = GraphData[currentTrackId];
            
            const timeDilation = handleBranchingLogic(trk, delta);
            const actualMoveDelta = (BiologyState.speedBase * BiologyState.speedMult * delta * timeDilation);
            
            splineT += actualMoveDelta / trk.length;

            if (splineT >= 1.0) {
                const overage = splineT - 1.0;
                
                if (trk.nextIds.length > 1) {
                    currentTrackId = selectedBranchId || trk.nextIds[0];
                } else if (trk.nextIds.length === 1) {
                    currentTrackId = trk.nextIds[0];
                } else {
                    currentTrackId = 'track_heart';
                }

                selectedBranchId = null;
                EnvironmentSys.clearPortals();
                
                const nextTrk = GraphData[currentTrackId];
                splineT = overage * (trk.length / nextTrk.length);
            }

            const newTrk = GraphData[currentTrackId];
            const frame = newTrk.getInterpolatedTransform(Math.min(splineT, 0.999));
            
            math_mat.makeBasis(frame.norm, frame.binorm, frame.tang);
            math_quat.setFromRotationMatrix(math_mat);

            const lerpFactor = 1.0 - Math.exp(-15.0 * delta);
            math_pos.copy(dolly.position).lerp(frame.pos, lerpFactor);
            
            dolly.position.copy(math_pos);
            dolly.quaternion.slerp(math_quat, lerpFactor);

            if (!renderer.xr.isPresenting) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y += (targetRotY - camera.rotation.y) * 12 * delta;
                camera.rotation.x += (targetRotX - camera.rotation.x) * 12 * delta;
            } else {
                camera.rotation.set(0,0,0);
            }

            if (newTrk.type === BiomeType.LUNGS) {
                BiologyState.oxygen = Math.min(1.0, BiologyState.oxygen + 0.3 * delta);
                scene.fog.color.lerp(new THREE.Color(0x001122), 0.05);
            } else if (newTrk.type === BiomeType.MUSCLES || newTrk.type === BiomeType.BRAIN) {
                BiologyState.oxygen = Math.max(0.0, BiologyState.oxygen - 0.15 * delta);
                BiologyState.waste = Math.min(1.0, BiologyState.waste + 0.08 * delta);
                scene.fog.color.lerp(new THREE.Color(0x0a0005), 0.05);
            } else if (newTrk.type === BiomeType.KIDNEYS) {
                BiologyState.waste = Math.max(0.0, BiologyState.waste - 0.3 * delta);
                scene.fog.color.lerp(new THREE.Color(0x111100), 0.05);
            } else {
                BiologyState.oxygen = Math.max(0.0, BiologyState.oxygen - 0.02 * delta);
                scene.fog.color.lerp(new THREE.Color(0x110000), 0.05);
            }
            scene.background.copy(scene.fog.color);
            BiologyState.heartRate = Math.floor(65 + (BiologyState.speedMult - 1.0) * 40);

            const hBeat = (time % (60/BiologyState.heartRate));
            const pulse = (hBeat < 0.2) ? Math.sin((hBeat/0.2)*Math.PI) : 0;
            
            EnvironmentSys.centerLight.intensity = pulse * 2000;
            EnvironmentSys.centerLight.position.copy(dolly.position);
            for(let key in GraphData) GraphData[key].updateUniforms(time, pulse);

            CellSys.update(delta, BiologyState.speedBase * 0.5, time);
            UISys.update(newTrk.title);
            if(AudioSys) AudioSys.update(BiologyState.speedMult, time);

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>
